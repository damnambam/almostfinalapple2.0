{"ast":null,"code":"import { decode, encode } from './text';\nconst defaultByteLength = 1024 * 8;\nconst hostBigEndian = (() => {\n  const array = new Uint8Array(4);\n  const view = new Uint32Array(array.buffer);\n  return !((view[0] = 1) & array[0]);\n})();\nconst typedArrays = {\n  int8: globalThis.Int8Array,\n  uint8: globalThis.Uint8Array,\n  int16: globalThis.Int16Array,\n  uint16: globalThis.Uint16Array,\n  int32: globalThis.Int32Array,\n  uint32: globalThis.Uint32Array,\n  uint64: globalThis.BigUint64Array,\n  int64: globalThis.BigInt64Array,\n  float32: globalThis.Float32Array,\n  float64: globalThis.Float64Array\n};\nexport class IOBuffer {\n  /**\r\n   * Reference to the internal ArrayBuffer object.\r\n   */\n  buffer;\n  /**\r\n   * Byte length of the internal ArrayBuffer.\r\n   */\n  byteLength;\n  /**\r\n   * Byte offset of the internal ArrayBuffer.\r\n   */\n  byteOffset;\n  /**\r\n   * Byte length of the internal ArrayBuffer.\r\n   */\n  length;\n  /**\r\n   * The current offset of the buffer's pointer.\r\n   */\n  offset;\n  lastWrittenByte;\n  littleEndian;\n  _data;\n  _mark;\n  _marks;\n  /**\r\n   * Create a new IOBuffer.\r\n   * @param data - The data to construct the IOBuffer with.\r\n   * If data is a number, it will be the new buffer's length<br>\r\n   * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>\r\n   * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,\r\n   * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.\r\n   * @param options - An object for the options.\r\n   * @returns A new IOBuffer instance.\r\n   */\n  constructor(data = defaultByteLength, options = {}) {\n    let dataIsGiven = false;\n    if (typeof data === 'number') {\n      data = new ArrayBuffer(data);\n    } else {\n      dataIsGiven = true;\n      this.lastWrittenByte = data.byteLength;\n    }\n    const offset = options.offset ? options.offset >>> 0 : 0;\n    const byteLength = data.byteLength - offset;\n    let dvOffset = offset;\n    if (ArrayBuffer.isView(data) || data instanceof IOBuffer) {\n      if (data.byteLength !== data.buffer.byteLength) {\n        dvOffset = data.byteOffset + offset;\n      }\n      data = data.buffer;\n    }\n    if (dataIsGiven) {\n      this.lastWrittenByte = byteLength;\n    } else {\n      this.lastWrittenByte = 0;\n    }\n    this.buffer = data;\n    this.length = byteLength;\n    this.byteLength = byteLength;\n    this.byteOffset = dvOffset;\n    this.offset = 0;\n    this.littleEndian = true;\n    this._data = new DataView(this.buffer, dvOffset, byteLength);\n    this._mark = 0;\n    this._marks = [];\n  }\n  /**\r\n   * Checks if the memory allocated to the buffer is sufficient to store more\r\n   * bytes after the offset.\r\n   * @param byteLength - The needed memory in bytes.\r\n   * @returns `true` if there is sufficient space and `false` otherwise.\r\n   */\n  available(byteLength = 1) {\n    return this.offset + byteLength <= this.length;\n  }\n  /**\r\n   * Check if little-endian mode is used for reading and writing multi-byte\r\n   * values.\r\n   * @returns `true` if little-endian mode is used, `false` otherwise.\r\n   */\n  isLittleEndian() {\n    return this.littleEndian;\n  }\n  /**\r\n   * Set little-endian mode for reading and writing multi-byte values.\r\n   * @returns This.\r\n   */\n  setLittleEndian() {\n    this.littleEndian = true;\n    return this;\n  }\n  /**\r\n   * Check if big-endian mode is used for reading and writing multi-byte values.\r\n   * @returns `true` if big-endian mode is used, `false` otherwise.\r\n   */\n  isBigEndian() {\n    return !this.littleEndian;\n  }\n  /**\r\n   * Switches to big-endian mode for reading and writing multi-byte values.\r\n   * @returns This.\r\n   */\n  setBigEndian() {\n    this.littleEndian = false;\n    return this;\n  }\n  /**\r\n   * Move the pointer n bytes forward.\r\n   * @param n - Number of bytes to skip.\r\n   * @returns This.\r\n   */\n  skip(n = 1) {\n    this.offset += n;\n    return this;\n  }\n  /**\r\n   * Move the pointer n bytes backward.\r\n   * @param n - Number of bytes to move back.\r\n   * @returns This.\r\n   */\n  back(n = 1) {\n    this.offset -= n;\n    return this;\n  }\n  /**\r\n   * Move the pointer to the given offset.\r\n   * @param offset - The offset to move to.\r\n   * @returns This.\r\n   */\n  seek(offset) {\n    this.offset = offset;\n    return this;\n  }\n  /**\r\n   * Store the current pointer offset.\r\n   * @see {@link IOBuffer#reset}\r\n   * @returns This.\r\n   */\n  mark() {\n    this._mark = this.offset;\n    return this;\n  }\n  /**\r\n   * Move the pointer back to the last pointer offset set by mark.\r\n   * @see {@link IOBuffer#mark}\r\n   * @returns This.\r\n   */\n  reset() {\n    this.offset = this._mark;\n    return this;\n  }\n  /**\r\n   * Push the current pointer offset to the mark stack.\r\n   * @see {@link IOBuffer#popMark}\r\n   * @returns This.\r\n   */\n  pushMark() {\n    this._marks.push(this.offset);\n    return this;\n  }\n  /**\r\n   * Pop the last pointer offset from the mark stack, and set the current\r\n   * pointer offset to the popped value.\r\n   * @see {@link IOBuffer#pushMark}\r\n   * @returns This.\r\n   */\n  popMark() {\n    const offset = this._marks.pop();\n    if (offset === undefined) {\n      throw new Error('Mark stack empty');\n    }\n    this.seek(offset);\n    return this;\n  }\n  /**\r\n   * Move the pointer offset back to 0.\r\n   * @returns This.\r\n   */\n  rewind() {\n    this.offset = 0;\n    return this;\n  }\n  /**\r\n   * Make sure the buffer has sufficient memory to write a given byteLength at\r\n   * the current pointer offset.\r\n   * If the buffer's memory is insufficient, this method will create a new\r\n   * buffer (a copy) with a length that is twice (byteLength + current offset).\r\n   * @param byteLength - The needed memory in bytes.\r\n   * @returns This.\r\n   */\n  ensureAvailable(byteLength = 1) {\n    if (!this.available(byteLength)) {\n      const lengthNeeded = this.offset + byteLength;\n      const newLength = lengthNeeded * 2;\n      const newArray = new Uint8Array(newLength);\n      newArray.set(new Uint8Array(this.buffer));\n      this.buffer = newArray.buffer;\n      this.length = newLength;\n      this.byteLength = newLength;\n      this._data = new DataView(this.buffer);\n    }\n    return this;\n  }\n  /**\r\n   * Read a byte and return false if the byte's value is 0, or true otherwise.\r\n   * Moves pointer forward by one byte.\r\n   * @returns The read boolean.\r\n   */\n  readBoolean() {\n    return this.readUint8() !== 0;\n  }\n  /**\r\n   * Read a signed 8-bit integer and move pointer forward by 1 byte.\r\n   * @returns The read byte.\r\n   */\n  readInt8() {\n    return this._data.getInt8(this.offset++);\n  }\n  /**\r\n   * Read an unsigned 8-bit integer and move pointer forward by 1 byte.\r\n   * @returns The read byte.\r\n   */\n  readUint8() {\n    return this._data.getUint8(this.offset++);\n  }\n  /**\r\n   * Alias for {@link IOBuffer#readUint8}.\r\n   * @returns The read byte.\r\n   */\n  readByte() {\n    return this.readUint8();\n  }\n  /**\r\n   * Read `n` bytes and move pointer forward by `n` bytes.\r\n   * @param n - Number of bytes to read.\r\n   * @returns The read bytes.\r\n   */\n  readBytes(n = 1) {\n    return this.readArray(n, 'uint8');\n  }\n  /**\r\n   * Creates an array of corresponding to the type `type` and size `size`.\r\n   * For example type `uint8` will create a `Uint8Array`.\r\n   * @param size - size of the resulting array\r\n   * @param type - number type of elements to read\r\n   * @returns The read array.\r\n   */\n  readArray(size, type) {\n    const bytes = typedArrays[type].BYTES_PER_ELEMENT * size;\n    const offset = this.byteOffset + this.offset;\n    const slice = this.buffer.slice(offset, offset + bytes);\n    if (this.littleEndian === hostBigEndian && type !== 'uint8' && type !== 'int8') {\n      const slice = new Uint8Array(this.buffer.slice(offset, offset + bytes));\n      slice.reverse();\n      const returnArray = new typedArrays[type](slice.buffer);\n      this.offset += bytes;\n      returnArray.reverse();\n      return returnArray;\n    }\n    const returnArray = new typedArrays[type](slice);\n    this.offset += bytes;\n    return returnArray;\n  }\n  /**\r\n   * Read a 16-bit signed integer and move pointer forward by 2 bytes.\r\n   * @returns The read value.\r\n   */\n  readInt16() {\n    const value = this._data.getInt16(this.offset, this.littleEndian);\n    this.offset += 2;\n    return value;\n  }\n  /**\r\n   * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.\r\n   * @returns The read value.\r\n   */\n  readUint16() {\n    const value = this._data.getUint16(this.offset, this.littleEndian);\n    this.offset += 2;\n    return value;\n  }\n  /**\r\n   * Read a 32-bit signed integer and move pointer forward by 4 bytes.\r\n   * @returns The read value.\r\n   */\n  readInt32() {\n    const value = this._data.getInt32(this.offset, this.littleEndian);\n    this.offset += 4;\n    return value;\n  }\n  /**\r\n   * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.\r\n   * @returns The read value.\r\n   */\n  readUint32() {\n    const value = this._data.getUint32(this.offset, this.littleEndian);\n    this.offset += 4;\n    return value;\n  }\n  /**\r\n   * Read a 32-bit floating number and move pointer forward by 4 bytes.\r\n   * @returns The read value.\r\n   */\n  readFloat32() {\n    const value = this._data.getFloat32(this.offset, this.littleEndian);\n    this.offset += 4;\n    return value;\n  }\n  /**\r\n   * Read a 64-bit floating number and move pointer forward by 8 bytes.\r\n   * @returns The read value.\r\n   */\n  readFloat64() {\n    const value = this._data.getFloat64(this.offset, this.littleEndian);\n    this.offset += 8;\n    return value;\n  }\n  /**\r\n   * Read a 64-bit signed integer number and move pointer forward by 8 bytes.\r\n   * @returns The read value.\r\n   */\n  readBigInt64() {\n    const value = this._data.getBigInt64(this.offset, this.littleEndian);\n    this.offset += 8;\n    return value;\n  }\n  /**\r\n   * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.\r\n   * @returns The read value.\r\n   */\n  readBigUint64() {\n    const value = this._data.getBigUint64(this.offset, this.littleEndian);\n    this.offset += 8;\n    return value;\n  }\n  /**\r\n   * Read a 1-byte ASCII character and move pointer forward by 1 byte.\r\n   * @returns The read character.\r\n   */\n  readChar() {\n    // eslint-disable-next-line unicorn/prefer-code-point\n    return String.fromCharCode(this.readInt8());\n  }\n  /**\r\n   * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.\r\n   * @param n - Number of characters to read.\r\n   * @returns The read characters.\r\n   */\n  readChars(n = 1) {\n    let result = '';\n    for (let i = 0; i < n; i++) {\n      result += this.readChar();\n    }\n    return result;\n  }\n  /**\r\n   * Read the next `n` bytes, return a UTF-8 decoded string and move pointer\r\n   * forward by `n` bytes.\r\n   * @param n - Number of bytes to read.\r\n   * @returns The decoded string.\r\n   */\n  readUtf8(n = 1) {\n    return decode(this.readBytes(n));\n  }\n  /**\r\n   * Read the next `n` bytes, return a string decoded with `encoding` and move pointer\r\n   * forward by `n` bytes.\r\n   * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}\r\n   * @param n - Number of bytes to read.\r\n   * @param encoding - The encoding to use. Default is 'utf8'.\r\n   * @returns The decoded string.\r\n   */\n  decodeText(n = 1, encoding = 'utf8') {\n    return decode(this.readBytes(n), encoding);\n  }\n  /**\r\n   * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer\r\n   * forward by 1 byte.\r\n   * @param value - The value to write.\r\n   * @returns This.\r\n   */\n  writeBoolean(value) {\n    this.writeUint8(value ? 0xff : 0x00);\n    return this;\n  }\n  /**\r\n   * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.\r\n   * @param value - The value to write.\r\n   * @returns This.\r\n   */\n  writeInt8(value) {\n    this.ensureAvailable(1);\n    this._data.setInt8(this.offset++, value);\n    this._updateLastWrittenByte();\n    return this;\n  }\n  /**\r\n   * Write `value` as an 8-bit unsigned integer and move pointer forward by 1\r\n   * byte.\r\n   * @param value - The value to write.\r\n   * @returns This.\r\n   */\n  writeUint8(value) {\n    this.ensureAvailable(1);\n    this._data.setUint8(this.offset++, value);\n    this._updateLastWrittenByte();\n    return this;\n  }\n  /**\r\n   * An alias for {@link IOBuffer#writeUint8}.\r\n   * @param value - The value to write.\r\n   * @returns This.\r\n   */\n  writeByte(value) {\n    return this.writeUint8(value);\n  }\n  /**\r\n   * Write all elements of `bytes` as uint8 values and move pointer forward by\r\n   * `bytes.length` bytes.\r\n   * @param bytes - The array of bytes to write.\r\n   * @returns This.\r\n   */\n  writeBytes(bytes) {\n    this.ensureAvailable(bytes.length);\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let i = 0; i < bytes.length; i++) {\n      this._data.setUint8(this.offset++, bytes[i]);\n    }\n    this._updateLastWrittenByte();\n    return this;\n  }\n  /**\r\n   * Write `value` as a 16-bit signed integer and move pointer forward by 2\r\n   * bytes.\r\n   * @param value - The value to write.\r\n   * @returns This.\r\n   */\n  writeInt16(value) {\n    this.ensureAvailable(2);\n    this._data.setInt16(this.offset, value, this.littleEndian);\n    this.offset += 2;\n    this._updateLastWrittenByte();\n    return this;\n  }\n  /**\r\n   * Write `value` as a 16-bit unsigned integer and move pointer forward by 2\r\n   * bytes.\r\n   * @param value - The value to write.\r\n   * @returns This.\r\n   */\n  writeUint16(value) {\n    this.ensureAvailable(2);\n    this._data.setUint16(this.offset, value, this.littleEndian);\n    this.offset += 2;\n    this._updateLastWrittenByte();\n    return this;\n  }\n  /**\r\n   * Write `value` as a 32-bit signed integer and move pointer forward by 4\r\n   * bytes.\r\n   * @param value - The value to write.\r\n   * @returns This.\r\n   */\n  writeInt32(value) {\n    this.ensureAvailable(4);\n    this._data.setInt32(this.offset, value, this.littleEndian);\n    this.offset += 4;\n    this._updateLastWrittenByte();\n    return this;\n  }\n  /**\r\n   * Write `value` as a 32-bit unsigned integer and move pointer forward by 4\r\n   * bytes.\r\n   * @param value - The value to write.\r\n   * @returns This.\r\n   */\n  writeUint32(value) {\n    this.ensureAvailable(4);\n    this._data.setUint32(this.offset, value, this.littleEndian);\n    this.offset += 4;\n    this._updateLastWrittenByte();\n    return this;\n  }\n  /**\r\n   * Write `value` as a 32-bit floating number and move pointer forward by 4\r\n   * bytes.\r\n   * @param value - The value to write.\r\n   * @returns This.\r\n   */\n  writeFloat32(value) {\n    this.ensureAvailable(4);\n    this._data.setFloat32(this.offset, value, this.littleEndian);\n    this.offset += 4;\n    this._updateLastWrittenByte();\n    return this;\n  }\n  /**\r\n   * Write `value` as a 64-bit floating number and move pointer forward by 8\r\n   * bytes.\r\n   * @param value - The value to write.\r\n   * @returns This.\r\n   */\n  writeFloat64(value) {\n    this.ensureAvailable(8);\n    this._data.setFloat64(this.offset, value, this.littleEndian);\n    this.offset += 8;\n    this._updateLastWrittenByte();\n    return this;\n  }\n  /**\r\n   * Write `value` as a 64-bit signed bigint and move pointer forward by 8\r\n   * bytes.\r\n   * @param value - The value to write.\r\n   * @returns This.\r\n   */\n  writeBigInt64(value) {\n    this.ensureAvailable(8);\n    this._data.setBigInt64(this.offset, value, this.littleEndian);\n    this.offset += 8;\n    this._updateLastWrittenByte();\n    return this;\n  }\n  /**\r\n   * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8\r\n   * bytes.\r\n   * @param value - The value to write.\r\n   * @returns This.\r\n   */\n  writeBigUint64(value) {\n    this.ensureAvailable(8);\n    this._data.setBigUint64(this.offset, value, this.littleEndian);\n    this.offset += 8;\n    this._updateLastWrittenByte();\n    return this;\n  }\n  /**\r\n   * Write the charCode of `str`'s first character as an 8-bit unsigned integer\r\n   * and move pointer forward by 1 byte.\r\n   * @param str - The character to write.\r\n   * @returns This.\r\n   */\n  writeChar(str) {\n    // eslint-disable-next-line unicorn/prefer-code-point\n    return this.writeUint8(str.charCodeAt(0));\n  }\n  /**\r\n   * Write the charCodes of all `str`'s characters as 8-bit unsigned integers\r\n   * and move pointer forward by `str.length` bytes.\r\n   * @param str - The characters to write.\r\n   * @returns This.\r\n   */\n  writeChars(str) {\n    for (let i = 0; i < str.length; i++) {\n      // eslint-disable-next-line unicorn/prefer-code-point\n      this.writeUint8(str.charCodeAt(i));\n    }\n    return this;\n  }\n  /**\r\n   * UTF-8 encode and write `str` to the current pointer offset and move pointer\r\n   * forward according to the encoded length.\r\n   * @param str - The string to write.\r\n   * @returns This.\r\n   */\n  writeUtf8(str) {\n    return this.writeBytes(encode(str));\n  }\n  /**\r\n   * Export a Uint8Array view of the internal buffer.\r\n   * The view starts at the byte offset and its length\r\n   * is calculated to stop at the last written byte or the original length.\r\n   * @returns A new Uint8Array view.\r\n   */\n  toArray() {\n    return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);\n  }\n  /**\r\n   *  Get the total number of bytes written so far, regardless of the current offset.\r\n   * @returns - Total number of bytes.\r\n   */\n  getWrittenByteLength() {\n    return this.lastWrittenByte - this.byteOffset;\n  }\n  /**\r\n   * Update the last written byte offset\r\n   * @private\r\n   */\n  _updateLastWrittenByte() {\n    if (this.offset > this.lastWrittenByte) {\n      this.lastWrittenByte = this.offset;\n    }\n  }\n}","map":{"version":3,"names":["decode","encode","defaultByteLength","hostBigEndian","array","Uint8Array","view","Uint32Array","buffer","typedArrays","int8","globalThis","Int8Array","uint8","int16","Int16Array","uint16","Uint16Array","int32","Int32Array","uint32","uint64","BigUint64Array","int64","BigInt64Array","float32","Float32Array","float64","Float64Array","IOBuffer","byteLength","byteOffset","length","offset","lastWrittenByte","littleEndian","_data","_mark","_marks","constructor","data","options","dataIsGiven","ArrayBuffer","dvOffset","isView","DataView","available","isLittleEndian","setLittleEndian","isBigEndian","setBigEndian","skip","n","back","seek","mark","reset","pushMark","push","popMark","pop","undefined","Error","rewind","ensureAvailable","lengthNeeded","newLength","newArray","set","readBoolean","readUint8","readInt8","getInt8","getUint8","readByte","readBytes","readArray","size","type","bytes","BYTES_PER_ELEMENT","slice","reverse","returnArray","readInt16","value","getInt16","readUint16","getUint16","readInt32","getInt32","readUint32","getUint32","readFloat32","getFloat32","readFloat64","getFloat64","readBigInt64","getBigInt64","readBigUint64","getBigUint64","readChar","String","fromCharCode","readChars","result","i","readUtf8","decodeText","encoding","writeBoolean","writeUint8","writeInt8","setInt8","_updateLastWrittenByte","setUint8","writeByte","writeBytes","writeInt16","setInt16","writeUint16","setUint16","writeInt32","setInt32","writeUint32","setUint32","writeFloat32","setFloat32","writeFloat64","setFloat64","writeBigInt64","setBigInt64","writeBigUint64","setBigUint64","writeChar","str","charCodeAt","writeChars","writeUtf8","toArray","getWrittenByteLength"],"sources":["C:\\Users\\namil\\Desktop\\sanaapplenamlocal\\frontend\\node_modules\\iobuffer\\src\\IOBuffer.ts"],"sourcesContent":["import { decode, encode } from './text';\r\n\r\nconst defaultByteLength = 1024 * 8;\r\n\r\nconst hostBigEndian = (() => {\r\n  const array = new Uint8Array(4);\r\n  const view = new Uint32Array(array.buffer);\r\n  return !((view[0] = 1) & array[0]);\r\n})();\r\n\r\ntype InputData = number | ArrayBufferLike | ArrayBufferView | IOBuffer | Buffer;\r\n\r\nconst typedArrays = {\r\n  int8: globalThis.Int8Array,\r\n  uint8: globalThis.Uint8Array,\r\n  int16: globalThis.Int16Array,\r\n  uint16: globalThis.Uint16Array,\r\n  int32: globalThis.Int32Array,\r\n  uint32: globalThis.Uint32Array,\r\n  uint64: globalThis.BigUint64Array,\r\n  int64: globalThis.BigInt64Array,\r\n  float32: globalThis.Float32Array,\r\n  float64: globalThis.Float64Array,\r\n};\r\n\r\ntype TypedArrays = typeof typedArrays;\r\n\r\ninterface IOBufferOptions {\r\n  /**\r\n   * Ignore the first n bytes of the ArrayBuffer.\r\n   */\r\n  offset?: number;\r\n}\r\n\r\nexport class IOBuffer {\r\n  /**\r\n   * Reference to the internal ArrayBuffer object.\r\n   */\r\n  public buffer: ArrayBufferLike;\r\n\r\n  /**\r\n   * Byte length of the internal ArrayBuffer.\r\n   */\r\n  public byteLength: number;\r\n\r\n  /**\r\n   * Byte offset of the internal ArrayBuffer.\r\n   */\r\n  public byteOffset: number;\r\n\r\n  /**\r\n   * Byte length of the internal ArrayBuffer.\r\n   */\r\n  public length: number;\r\n\r\n  /**\r\n   * The current offset of the buffer's pointer.\r\n   */\r\n  public offset: number;\r\n\r\n  private lastWrittenByte: number;\r\n  private littleEndian: boolean;\r\n\r\n  private _data: DataView;\r\n  private _mark: number;\r\n  private _marks: number[];\r\n\r\n  /**\r\n   * Create a new IOBuffer.\r\n   * @param data - The data to construct the IOBuffer with.\r\n   * If data is a number, it will be the new buffer's length<br>\r\n   * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>\r\n   * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,\r\n   * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.\r\n   * @param options - An object for the options.\r\n   * @returns A new IOBuffer instance.\r\n   */\r\n  public constructor(\r\n    data: InputData = defaultByteLength,\r\n    options: IOBufferOptions = {},\r\n  ) {\r\n    let dataIsGiven = false;\r\n    if (typeof data === 'number') {\r\n      data = new ArrayBuffer(data);\r\n    } else {\r\n      dataIsGiven = true;\r\n      this.lastWrittenByte = data.byteLength;\r\n    }\r\n    const offset = options.offset ? options.offset >>> 0 : 0;\r\n    const byteLength = data.byteLength - offset;\r\n    let dvOffset = offset;\r\n    if (ArrayBuffer.isView(data) || data instanceof IOBuffer) {\r\n      if (data.byteLength !== data.buffer.byteLength) {\r\n        dvOffset = data.byteOffset + offset;\r\n      }\r\n      data = data.buffer;\r\n    }\r\n    if (dataIsGiven) {\r\n      this.lastWrittenByte = byteLength;\r\n    } else {\r\n      this.lastWrittenByte = 0;\r\n    }\r\n    this.buffer = data;\r\n    this.length = byteLength;\r\n    this.byteLength = byteLength;\r\n    this.byteOffset = dvOffset;\r\n    this.offset = 0;\r\n    this.littleEndian = true;\r\n    this._data = new DataView(this.buffer, dvOffset, byteLength);\r\n    this._mark = 0;\r\n    this._marks = [];\r\n  }\r\n\r\n  /**\r\n   * Checks if the memory allocated to the buffer is sufficient to store more\r\n   * bytes after the offset.\r\n   * @param byteLength - The needed memory in bytes.\r\n   * @returns `true` if there is sufficient space and `false` otherwise.\r\n   */\r\n  public available(byteLength = 1): boolean {\r\n    return this.offset + byteLength <= this.length;\r\n  }\r\n\r\n  /**\r\n   * Check if little-endian mode is used for reading and writing multi-byte\r\n   * values.\r\n   * @returns `true` if little-endian mode is used, `false` otherwise.\r\n   */\r\n  public isLittleEndian(): boolean {\r\n    return this.littleEndian;\r\n  }\r\n\r\n  /**\r\n   * Set little-endian mode for reading and writing multi-byte values.\r\n   * @returns This.\r\n   */\r\n  public setLittleEndian(): this {\r\n    this.littleEndian = true;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Check if big-endian mode is used for reading and writing multi-byte values.\r\n   * @returns `true` if big-endian mode is used, `false` otherwise.\r\n   */\r\n  public isBigEndian(): boolean {\r\n    return !this.littleEndian;\r\n  }\r\n\r\n  /**\r\n   * Switches to big-endian mode for reading and writing multi-byte values.\r\n   * @returns This.\r\n   */\r\n  public setBigEndian(): this {\r\n    this.littleEndian = false;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Move the pointer n bytes forward.\r\n   * @param n - Number of bytes to skip.\r\n   * @returns This.\r\n   */\r\n  public skip(n = 1): this {\r\n    this.offset += n;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Move the pointer n bytes backward.\r\n   * @param n - Number of bytes to move back.\r\n   * @returns This.\r\n   */\r\n  public back(n = 1): this {\r\n    this.offset -= n;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Move the pointer to the given offset.\r\n   * @param offset - The offset to move to.\r\n   * @returns This.\r\n   */\r\n  public seek(offset: number): this {\r\n    this.offset = offset;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Store the current pointer offset.\r\n   * @see {@link IOBuffer#reset}\r\n   * @returns This.\r\n   */\r\n  public mark(): this {\r\n    this._mark = this.offset;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Move the pointer back to the last pointer offset set by mark.\r\n   * @see {@link IOBuffer#mark}\r\n   * @returns This.\r\n   */\r\n  public reset(): this {\r\n    this.offset = this._mark;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Push the current pointer offset to the mark stack.\r\n   * @see {@link IOBuffer#popMark}\r\n   * @returns This.\r\n   */\r\n  public pushMark(): this {\r\n    this._marks.push(this.offset);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Pop the last pointer offset from the mark stack, and set the current\r\n   * pointer offset to the popped value.\r\n   * @see {@link IOBuffer#pushMark}\r\n   * @returns This.\r\n   */\r\n  public popMark(): this {\r\n    const offset = this._marks.pop();\r\n    if (offset === undefined) {\r\n      throw new Error('Mark stack empty');\r\n    }\r\n    this.seek(offset);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Move the pointer offset back to 0.\r\n   * @returns This.\r\n   */\r\n  public rewind(): this {\r\n    this.offset = 0;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Make sure the buffer has sufficient memory to write a given byteLength at\r\n   * the current pointer offset.\r\n   * If the buffer's memory is insufficient, this method will create a new\r\n   * buffer (a copy) with a length that is twice (byteLength + current offset).\r\n   * @param byteLength - The needed memory in bytes.\r\n   * @returns This.\r\n   */\r\n  public ensureAvailable(byteLength = 1): this {\r\n    if (!this.available(byteLength)) {\r\n      const lengthNeeded = this.offset + byteLength;\r\n      const newLength = lengthNeeded * 2;\r\n      const newArray = new Uint8Array(newLength);\r\n      newArray.set(new Uint8Array(this.buffer));\r\n      this.buffer = newArray.buffer;\r\n      this.length = newLength;\r\n      this.byteLength = newLength;\r\n      this._data = new DataView(this.buffer);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Read a byte and return false if the byte's value is 0, or true otherwise.\r\n   * Moves pointer forward by one byte.\r\n   * @returns The read boolean.\r\n   */\r\n  public readBoolean(): boolean {\r\n    return this.readUint8() !== 0;\r\n  }\r\n\r\n  /**\r\n   * Read a signed 8-bit integer and move pointer forward by 1 byte.\r\n   * @returns The read byte.\r\n   */\r\n  public readInt8(): number {\r\n    return this._data.getInt8(this.offset++);\r\n  }\r\n\r\n  /**\r\n   * Read an unsigned 8-bit integer and move pointer forward by 1 byte.\r\n   * @returns The read byte.\r\n   */\r\n  public readUint8(): number {\r\n    return this._data.getUint8(this.offset++);\r\n  }\r\n\r\n  /**\r\n   * Alias for {@link IOBuffer#readUint8}.\r\n   * @returns The read byte.\r\n   */\r\n  public readByte(): number {\r\n    return this.readUint8();\r\n  }\r\n\r\n  /**\r\n   * Read `n` bytes and move pointer forward by `n` bytes.\r\n   * @param n - Number of bytes to read.\r\n   * @returns The read bytes.\r\n   */\r\n  public readBytes(n = 1): Uint8Array {\r\n    return this.readArray(n, 'uint8');\r\n  }\r\n\r\n  /**\r\n   * Creates an array of corresponding to the type `type` and size `size`.\r\n   * For example type `uint8` will create a `Uint8Array`.\r\n   * @param size - size of the resulting array\r\n   * @param type - number type of elements to read\r\n   * @returns The read array.\r\n   */\r\n  public readArray<T extends keyof typeof typedArrays>(\r\n    size: number,\r\n    type: T,\r\n  ): InstanceType<TypedArrays[T]> {\r\n    const bytes = typedArrays[type].BYTES_PER_ELEMENT * size;\r\n    const offset = this.byteOffset + this.offset;\r\n    const slice = this.buffer.slice(offset, offset + bytes);\r\n    if (\r\n      this.littleEndian === hostBigEndian &&\r\n      type !== 'uint8' &&\r\n      type !== 'int8'\r\n    ) {\r\n      const slice = new Uint8Array(this.buffer.slice(offset, offset + bytes));\r\n      slice.reverse();\r\n      const returnArray = new typedArrays[type](slice.buffer);\r\n      this.offset += bytes;\r\n      returnArray.reverse();\r\n      return returnArray as InstanceType<TypedArrays[T]>;\r\n    }\r\n    const returnArray = new typedArrays[type](slice);\r\n    this.offset += bytes;\r\n    return returnArray as InstanceType<TypedArrays[T]>;\r\n  }\r\n\r\n  /**\r\n   * Read a 16-bit signed integer and move pointer forward by 2 bytes.\r\n   * @returns The read value.\r\n   */\r\n  public readInt16(): number {\r\n    const value = this._data.getInt16(this.offset, this.littleEndian);\r\n    this.offset += 2;\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.\r\n   * @returns The read value.\r\n   */\r\n  public readUint16(): number {\r\n    const value = this._data.getUint16(this.offset, this.littleEndian);\r\n    this.offset += 2;\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Read a 32-bit signed integer and move pointer forward by 4 bytes.\r\n   * @returns The read value.\r\n   */\r\n  public readInt32(): number {\r\n    const value = this._data.getInt32(this.offset, this.littleEndian);\r\n    this.offset += 4;\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.\r\n   * @returns The read value.\r\n   */\r\n  public readUint32(): number {\r\n    const value = this._data.getUint32(this.offset, this.littleEndian);\r\n    this.offset += 4;\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Read a 32-bit floating number and move pointer forward by 4 bytes.\r\n   * @returns The read value.\r\n   */\r\n  public readFloat32(): number {\r\n    const value = this._data.getFloat32(this.offset, this.littleEndian);\r\n    this.offset += 4;\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Read a 64-bit floating number and move pointer forward by 8 bytes.\r\n   * @returns The read value.\r\n   */\r\n  public readFloat64(): number {\r\n    const value = this._data.getFloat64(this.offset, this.littleEndian);\r\n    this.offset += 8;\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Read a 64-bit signed integer number and move pointer forward by 8 bytes.\r\n   * @returns The read value.\r\n   */\r\n  public readBigInt64(): bigint {\r\n    const value = this._data.getBigInt64(this.offset, this.littleEndian);\r\n    this.offset += 8;\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.\r\n   * @returns The read value.\r\n   */\r\n  public readBigUint64(): bigint {\r\n    const value = this._data.getBigUint64(this.offset, this.littleEndian);\r\n    this.offset += 8;\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Read a 1-byte ASCII character and move pointer forward by 1 byte.\r\n   * @returns The read character.\r\n   */\r\n  public readChar(): string {\r\n    // eslint-disable-next-line unicorn/prefer-code-point\r\n    return String.fromCharCode(this.readInt8());\r\n  }\r\n\r\n  /**\r\n   * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.\r\n   * @param n - Number of characters to read.\r\n   * @returns The read characters.\r\n   */\r\n  public readChars(n = 1): string {\r\n    let result = '';\r\n    for (let i = 0; i < n; i++) {\r\n      result += this.readChar();\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Read the next `n` bytes, return a UTF-8 decoded string and move pointer\r\n   * forward by `n` bytes.\r\n   * @param n - Number of bytes to read.\r\n   * @returns The decoded string.\r\n   */\r\n  public readUtf8(n = 1): string {\r\n    return decode(this.readBytes(n));\r\n  }\r\n\r\n  /**\r\n   * Read the next `n` bytes, return a string decoded with `encoding` and move pointer\r\n   * forward by `n` bytes.\r\n   * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}\r\n   * @param n - Number of bytes to read.\r\n   * @param encoding - The encoding to use. Default is 'utf8'.\r\n   * @returns The decoded string.\r\n   */\r\n  public decodeText(n = 1, encoding = 'utf8'): string {\r\n    return decode(this.readBytes(n), encoding);\r\n  }\r\n\r\n  /**\r\n   * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer\r\n   * forward by 1 byte.\r\n   * @param value - The value to write.\r\n   * @returns This.\r\n   */\r\n  public writeBoolean(value: unknown): this {\r\n    this.writeUint8(value ? 0xff : 0x00);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.\r\n   * @param value - The value to write.\r\n   * @returns This.\r\n   */\r\n  public writeInt8(value: number): this {\r\n    this.ensureAvailable(1);\r\n    this._data.setInt8(this.offset++, value);\r\n    this._updateLastWrittenByte();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Write `value` as an 8-bit unsigned integer and move pointer forward by 1\r\n   * byte.\r\n   * @param value - The value to write.\r\n   * @returns This.\r\n   */\r\n  public writeUint8(value: number): this {\r\n    this.ensureAvailable(1);\r\n    this._data.setUint8(this.offset++, value);\r\n    this._updateLastWrittenByte();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * An alias for {@link IOBuffer#writeUint8}.\r\n   * @param value - The value to write.\r\n   * @returns This.\r\n   */\r\n  public writeByte(value: number): this {\r\n    return this.writeUint8(value);\r\n  }\r\n\r\n  /**\r\n   * Write all elements of `bytes` as uint8 values and move pointer forward by\r\n   * `bytes.length` bytes.\r\n   * @param bytes - The array of bytes to write.\r\n   * @returns This.\r\n   */\r\n  public writeBytes(bytes: ArrayLike<number>): this {\r\n    this.ensureAvailable(bytes.length);\r\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\r\n    for (let i = 0; i < bytes.length; i++) {\r\n      this._data.setUint8(this.offset++, bytes[i]);\r\n    }\r\n    this._updateLastWrittenByte();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Write `value` as a 16-bit signed integer and move pointer forward by 2\r\n   * bytes.\r\n   * @param value - The value to write.\r\n   * @returns This.\r\n   */\r\n  public writeInt16(value: number): this {\r\n    this.ensureAvailable(2);\r\n    this._data.setInt16(this.offset, value, this.littleEndian);\r\n    this.offset += 2;\r\n    this._updateLastWrittenByte();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Write `value` as a 16-bit unsigned integer and move pointer forward by 2\r\n   * bytes.\r\n   * @param value - The value to write.\r\n   * @returns This.\r\n   */\r\n  public writeUint16(value: number): this {\r\n    this.ensureAvailable(2);\r\n    this._data.setUint16(this.offset, value, this.littleEndian);\r\n    this.offset += 2;\r\n    this._updateLastWrittenByte();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Write `value` as a 32-bit signed integer and move pointer forward by 4\r\n   * bytes.\r\n   * @param value - The value to write.\r\n   * @returns This.\r\n   */\r\n  public writeInt32(value: number): this {\r\n    this.ensureAvailable(4);\r\n    this._data.setInt32(this.offset, value, this.littleEndian);\r\n    this.offset += 4;\r\n    this._updateLastWrittenByte();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Write `value` as a 32-bit unsigned integer and move pointer forward by 4\r\n   * bytes.\r\n   * @param value - The value to write.\r\n   * @returns This.\r\n   */\r\n  public writeUint32(value: number): this {\r\n    this.ensureAvailable(4);\r\n    this._data.setUint32(this.offset, value, this.littleEndian);\r\n    this.offset += 4;\r\n    this._updateLastWrittenByte();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Write `value` as a 32-bit floating number and move pointer forward by 4\r\n   * bytes.\r\n   * @param value - The value to write.\r\n   * @returns This.\r\n   */\r\n  public writeFloat32(value: number): this {\r\n    this.ensureAvailable(4);\r\n    this._data.setFloat32(this.offset, value, this.littleEndian);\r\n    this.offset += 4;\r\n    this._updateLastWrittenByte();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Write `value` as a 64-bit floating number and move pointer forward by 8\r\n   * bytes.\r\n   * @param value - The value to write.\r\n   * @returns This.\r\n   */\r\n  public writeFloat64(value: number): this {\r\n    this.ensureAvailable(8);\r\n    this._data.setFloat64(this.offset, value, this.littleEndian);\r\n    this.offset += 8;\r\n    this._updateLastWrittenByte();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Write `value` as a 64-bit signed bigint and move pointer forward by 8\r\n   * bytes.\r\n   * @param value - The value to write.\r\n   * @returns This.\r\n   */\r\n  public writeBigInt64(value: bigint): this {\r\n    this.ensureAvailable(8);\r\n    this._data.setBigInt64(this.offset, value, this.littleEndian);\r\n    this.offset += 8;\r\n    this._updateLastWrittenByte();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8\r\n   * bytes.\r\n   * @param value - The value to write.\r\n   * @returns This.\r\n   */\r\n  public writeBigUint64(value: bigint): this {\r\n    this.ensureAvailable(8);\r\n    this._data.setBigUint64(this.offset, value, this.littleEndian);\r\n    this.offset += 8;\r\n    this._updateLastWrittenByte();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Write the charCode of `str`'s first character as an 8-bit unsigned integer\r\n   * and move pointer forward by 1 byte.\r\n   * @param str - The character to write.\r\n   * @returns This.\r\n   */\r\n  public writeChar(str: string): this {\r\n    // eslint-disable-next-line unicorn/prefer-code-point\r\n    return this.writeUint8(str.charCodeAt(0));\r\n  }\r\n\r\n  /**\r\n   * Write the charCodes of all `str`'s characters as 8-bit unsigned integers\r\n   * and move pointer forward by `str.length` bytes.\r\n   * @param str - The characters to write.\r\n   * @returns This.\r\n   */\r\n  public writeChars(str: string): this {\r\n    for (let i = 0; i < str.length; i++) {\r\n      // eslint-disable-next-line unicorn/prefer-code-point\r\n      this.writeUint8(str.charCodeAt(i));\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * UTF-8 encode and write `str` to the current pointer offset and move pointer\r\n   * forward according to the encoded length.\r\n   * @param str - The string to write.\r\n   * @returns This.\r\n   */\r\n  public writeUtf8(str: string): this {\r\n    return this.writeBytes(encode(str));\r\n  }\r\n\r\n  /**\r\n   * Export a Uint8Array view of the internal buffer.\r\n   * The view starts at the byte offset and its length\r\n   * is calculated to stop at the last written byte or the original length.\r\n   * @returns A new Uint8Array view.\r\n   */\r\n  public toArray(): Uint8Array {\r\n    return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);\r\n  }\r\n\r\n  /**\r\n   *  Get the total number of bytes written so far, regardless of the current offset.\r\n   * @returns - Total number of bytes.\r\n   */\r\n  public getWrittenByteLength() {\r\n    return this.lastWrittenByte - this.byteOffset;\r\n  }\r\n\r\n  /**\r\n   * Update the last written byte offset\r\n   * @private\r\n   */\r\n  private _updateLastWrittenByte(): void {\r\n    if (this.offset > this.lastWrittenByte) {\r\n      this.lastWrittenByte = this.offset;\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}