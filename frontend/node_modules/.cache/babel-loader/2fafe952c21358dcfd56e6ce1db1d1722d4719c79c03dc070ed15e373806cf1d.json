{"ast":null,"code":"import { IOBuffer } from 'iobuffer';\nimport { inflate, Inflate as Inflator } from 'pako';\nimport { checkCrc } from './helpers/crc';\nimport { decodeInterlaceAdam7 } from './helpers/decodeInterlaceAdam7';\nimport { decodeInterlaceNull } from './helpers/decodeInterlaceNull';\nimport { checkSignature } from './helpers/signature';\nimport { decodetEXt, readKeyword, textChunkName } from './helpers/text';\nimport { ColorType, CompressionMethod, DisposeOpType, FilterMethod, InterlaceMethod, BlendOpType } from './internalTypes';\nexport default class PngDecoder extends IOBuffer {\n  _checkCrc;\n  _inflator;\n  _png;\n  _apng;\n  _end;\n  _hasPalette;\n  _palette;\n  _hasTransparency;\n  _transparency;\n  _compressionMethod;\n  _filterMethod;\n  _interlaceMethod;\n  _colorType;\n  _isAnimated;\n  _numberOfFrames;\n  _numberOfPlays;\n  _frames;\n  _writingDataChunks;\n  constructor(data, options = {}) {\n    super(data);\n    const {\n      checkCrc = false\n    } = options;\n    this._checkCrc = checkCrc;\n    this._inflator = new Inflator();\n    this._png = {\n      width: -1,\n      height: -1,\n      channels: -1,\n      data: new Uint8Array(0),\n      depth: 1,\n      text: {}\n    };\n    this._apng = {\n      width: -1,\n      height: -1,\n      channels: -1,\n      depth: 1,\n      numberOfFrames: 1,\n      numberOfPlays: 0,\n      text: {},\n      frames: []\n    };\n    this._end = false;\n    this._hasPalette = false;\n    this._palette = [];\n    this._hasTransparency = false;\n    this._transparency = new Uint16Array(0);\n    this._compressionMethod = CompressionMethod.UNKNOWN;\n    this._filterMethod = FilterMethod.UNKNOWN;\n    this._interlaceMethod = InterlaceMethod.UNKNOWN;\n    this._colorType = ColorType.UNKNOWN;\n    this._isAnimated = false;\n    this._numberOfFrames = 1;\n    this._numberOfPlays = 0;\n    this._frames = [];\n    this._writingDataChunks = false;\n    // PNG is always big endian\n    // https://www.w3.org/TR/PNG/#7Integers-and-byte-order\n    this.setBigEndian();\n  }\n  decode() {\n    checkSignature(this);\n    while (!this._end) {\n      const length = this.readUint32();\n      const type = this.readChars(4);\n      this.decodeChunk(length, type);\n    }\n    this.decodeImage();\n    return this._png;\n  }\n  decodeApng() {\n    checkSignature(this);\n    while (!this._end) {\n      const length = this.readUint32();\n      const type = this.readChars(4);\n      this.decodeApngChunk(length, type);\n    }\n    this.decodeApngImage();\n    return this._apng;\n  }\n  // https://www.w3.org/TR/PNG/#5Chunk-layout\n  decodeChunk(length, type) {\n    const offset = this.offset;\n    switch (type) {\n      // 11.2 Critical chunks\n      case 'IHDR':\n        // 11.2.2 IHDR Image header\n        this.decodeIHDR();\n        break;\n      case 'PLTE':\n        // 11.2.3 PLTE Palette\n        this.decodePLTE(length);\n        break;\n      case 'IDAT':\n        // 11.2.4 IDAT Image data\n        this.decodeIDAT(length);\n        break;\n      case 'IEND':\n        // 11.2.5 IEND Image trailer\n        this._end = true;\n        break;\n      // 11.3 Ancillary chunks\n      case 'tRNS':\n        // 11.3.2.1 tRNS Transparency\n        this.decodetRNS(length);\n        break;\n      case 'iCCP':\n        // 11.3.3.3 iCCP Embedded ICC profile\n        this.decodeiCCP(length);\n        break;\n      case textChunkName:\n        // 11.3.4.3 tEXt Textual data\n        decodetEXt(this._png.text, this, length);\n        break;\n      case 'pHYs':\n        // 11.3.5.3 pHYs Physical pixel dimensions\n        this.decodepHYs();\n        break;\n      default:\n        this.skip(length);\n        break;\n    }\n    if (this.offset - offset !== length) {\n      throw new Error(`Length mismatch while decoding chunk ${type}`);\n    }\n    if (this._checkCrc) {\n      checkCrc(this, length + 4, type);\n    } else {\n      this.skip(4);\n    }\n  }\n  decodeApngChunk(length, type) {\n    const offset = this.offset;\n    if (type !== 'fdAT' && type !== 'IDAT' && this._writingDataChunks) {\n      this.pushDataToFrame();\n    }\n    switch (type) {\n      case 'acTL':\n        this.decodeACTL();\n        break;\n      case 'fcTL':\n        this.decodeFCTL();\n        break;\n      case 'fdAT':\n        this.decodeFDAT(length);\n        break;\n      default:\n        this.decodeChunk(length, type);\n        this.offset = offset + length;\n        break;\n    }\n    if (this.offset - offset !== length) {\n      throw new Error(`Length mismatch while decoding chunk ${type}`);\n    }\n    if (this._checkCrc) {\n      checkCrc(this, length + 4, type);\n    } else {\n      this.skip(4);\n    }\n  }\n  // https://www.w3.org/TR/PNG/#11IHDR\n  decodeIHDR() {\n    const image = this._png;\n    image.width = this.readUint32();\n    image.height = this.readUint32();\n    image.depth = checkBitDepth(this.readUint8());\n    const colorType = this.readUint8();\n    this._colorType = colorType;\n    let channels;\n    switch (colorType) {\n      case ColorType.GREYSCALE:\n        channels = 1;\n        break;\n      case ColorType.TRUECOLOUR:\n        channels = 3;\n        break;\n      case ColorType.INDEXED_COLOUR:\n        channels = 1;\n        break;\n      case ColorType.GREYSCALE_ALPHA:\n        channels = 2;\n        break;\n      case ColorType.TRUECOLOUR_ALPHA:\n        channels = 4;\n        break;\n      // Kept for exhaustiveness.\n      // eslint-disable-next-line unicorn/no-useless-switch-case\n      case ColorType.UNKNOWN:\n      default:\n        throw new Error(`Unknown color type: ${colorType}`);\n    }\n    this._png.channels = channels;\n    this._compressionMethod = this.readUint8();\n    if (this._compressionMethod !== CompressionMethod.DEFLATE) {\n      throw new Error(`Unsupported compression method: ${this._compressionMethod}`);\n    }\n    this._filterMethod = this.readUint8();\n    this._interlaceMethod = this.readUint8();\n  }\n  decodeACTL() {\n    this._numberOfFrames = this.readUint32();\n    this._numberOfPlays = this.readUint32();\n    this._isAnimated = true;\n  }\n  decodeFCTL() {\n    const image = {\n      sequenceNumber: this.readUint32(),\n      width: this.readUint32(),\n      height: this.readUint32(),\n      xOffset: this.readUint32(),\n      yOffset: this.readUint32(),\n      delayNumber: this.readUint16(),\n      delayDenominator: this.readUint16(),\n      disposeOp: this.readUint8(),\n      blendOp: this.readUint8(),\n      data: new Uint8Array(0)\n    };\n    this._frames.push(image);\n  }\n  // https://www.w3.org/TR/PNG/#11PLTE\n  decodePLTE(length) {\n    if (length % 3 !== 0) {\n      throw new RangeError(`PLTE field length must be a multiple of 3. Got ${length}`);\n    }\n    const l = length / 3;\n    this._hasPalette = true;\n    const palette = [];\n    this._palette = palette;\n    for (let i = 0; i < l; i++) {\n      palette.push([this.readUint8(), this.readUint8(), this.readUint8()]);\n    }\n  }\n  // https://www.w3.org/TR/PNG/#11IDAT\n  decodeIDAT(length) {\n    this._writingDataChunks = true;\n    const dataLength = length;\n    const dataOffset = this.offset + this.byteOffset;\n    this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));\n    if (this._inflator.err) {\n      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);\n    }\n    this.skip(length);\n  }\n  decodeFDAT(length) {\n    this._writingDataChunks = true;\n    let dataLength = length;\n    let dataOffset = this.offset + this.byteOffset;\n    dataOffset += 4;\n    dataLength -= 4;\n    this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));\n    if (this._inflator.err) {\n      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);\n    }\n    this.skip(length);\n  }\n  // https://www.w3.org/TR/PNG/#11tRNS\n  decodetRNS(length) {\n    switch (this._colorType) {\n      case ColorType.GREYSCALE:\n      case ColorType.TRUECOLOUR:\n        {\n          if (length % 2 !== 0) {\n            throw new RangeError(`tRNS chunk length must be a multiple of 2. Got ${length}`);\n          }\n          if (length / 2 > this._png.width * this._png.height) {\n            throw new Error(`tRNS chunk contains more alpha values than there are pixels (${length / 2} vs ${this._png.width * this._png.height})`);\n          }\n          this._hasTransparency = true;\n          this._transparency = new Uint16Array(length / 2);\n          for (let i = 0; i < length / 2; i++) {\n            this._transparency[i] = this.readUint16();\n          }\n          break;\n        }\n      case ColorType.INDEXED_COLOUR:\n        {\n          if (length > this._palette.length) {\n            throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${length} vs ${this._palette.length})`);\n          }\n          let i = 0;\n          for (; i < length; i++) {\n            const alpha = this.readByte();\n            this._palette[i].push(alpha);\n          }\n          for (; i < this._palette.length; i++) {\n            this._palette[i].push(255);\n          }\n          break;\n        }\n      // Kept for exhaustiveness.\n      /* eslint-disable unicorn/no-useless-switch-case */\n      case ColorType.UNKNOWN:\n      case ColorType.GREYSCALE_ALPHA:\n      case ColorType.TRUECOLOUR_ALPHA:\n      default:\n        {\n          throw new Error(`tRNS chunk is not supported for color type ${this._colorType}`);\n        }\n      /* eslint-enable unicorn/no-useless-switch-case */\n    }\n  }\n  // https://www.w3.org/TR/PNG/#11iCCP\n  decodeiCCP(length) {\n    const name = readKeyword(this);\n    const compressionMethod = this.readUint8();\n    if (compressionMethod !== CompressionMethod.DEFLATE) {\n      throw new Error(`Unsupported iCCP compression method: ${compressionMethod}`);\n    }\n    const compressedProfile = this.readBytes(length - name.length - 2);\n    this._png.iccEmbeddedProfile = {\n      name,\n      profile: inflate(compressedProfile)\n    };\n  }\n  // https://www.w3.org/TR/PNG/#11pHYs\n  decodepHYs() {\n    const ppuX = this.readUint32();\n    const ppuY = this.readUint32();\n    const unitSpecifier = this.readByte();\n    this._png.resolution = {\n      x: ppuX,\n      y: ppuY,\n      unit: unitSpecifier\n    };\n  }\n  decodeApngImage() {\n    this._apng.width = this._png.width;\n    this._apng.height = this._png.height;\n    this._apng.channels = this._png.channels;\n    this._apng.depth = this._png.depth;\n    this._apng.numberOfFrames = this._numberOfFrames;\n    this._apng.numberOfPlays = this._numberOfPlays;\n    this._apng.text = this._png.text;\n    this._apng.resolution = this._png.resolution;\n    for (let i = 0; i < this._numberOfFrames; i++) {\n      const newFrame = {\n        sequenceNumber: this._frames[i].sequenceNumber,\n        delayNumber: this._frames[i].delayNumber,\n        delayDenominator: this._frames[i].delayDenominator,\n        data: this._apng.depth === 8 ? new Uint8Array(this._apng.width * this._apng.height * this._apng.channels) : new Uint16Array(this._apng.width * this._apng.height * this._apng.channels)\n      };\n      const frame = this._frames.at(i);\n      if (frame) {\n        frame.data = decodeInterlaceNull({\n          data: frame.data,\n          width: frame.width,\n          height: frame.height,\n          channels: this._apng.channels,\n          depth: this._apng.depth\n        });\n        if (this._hasPalette) {\n          this._apng.palette = this._palette;\n        }\n        if (this._hasTransparency) {\n          this._apng.transparency = this._transparency;\n        }\n        if (i === 0 || frame.xOffset === 0 && frame.yOffset === 0 && frame.width === this._png.width && frame.height === this._png.height) {\n          newFrame.data = frame.data;\n        } else {\n          const prevFrame = this._apng.frames.at(i - 1);\n          this.disposeFrame(frame, prevFrame, newFrame);\n          this.addFrameDataToCanvas(newFrame, frame);\n        }\n        this._apng.frames.push(newFrame);\n      }\n    }\n    return this._apng;\n  }\n  disposeFrame(frame, prevFrame, imageFrame) {\n    switch (frame.disposeOp) {\n      case DisposeOpType.NONE:\n        break;\n      case DisposeOpType.BACKGROUND:\n        for (let row = 0; row < this._png.height; row++) {\n          for (let col = 0; col < this._png.width; col++) {\n            const index = (row * frame.width + col) * this._png.channels;\n            for (let channel = 0; channel < this._png.channels; channel++) {\n              imageFrame.data[index + channel] = 0;\n            }\n          }\n        }\n        break;\n      case DisposeOpType.PREVIOUS:\n        imageFrame.data.set(prevFrame.data);\n        break;\n      default:\n        throw new Error('Unknown disposeOp');\n    }\n  }\n  addFrameDataToCanvas(imageFrame, frame) {\n    const maxValue = 1 << this._png.depth;\n    const calculatePixelIndices = (row, col) => {\n      const index = ((row + frame.yOffset) * this._png.width + frame.xOffset + col) * this._png.channels;\n      const frameIndex = (row * frame.width + col) * this._png.channels;\n      return {\n        index,\n        frameIndex\n      };\n    };\n    switch (frame.blendOp) {\n      case BlendOpType.SOURCE:\n        for (let row = 0; row < frame.height; row++) {\n          for (let col = 0; col < frame.width; col++) {\n            const {\n              index,\n              frameIndex\n            } = calculatePixelIndices(row, col);\n            for (let channel = 0; channel < this._png.channels; channel++) {\n              imageFrame.data[index + channel] = frame.data[frameIndex + channel];\n            }\n          }\n        }\n        break;\n      // https://www.w3.org/TR/png-3/#13Alpha-channel-processing\n      case BlendOpType.OVER:\n        for (let row = 0; row < frame.height; row++) {\n          for (let col = 0; col < frame.width; col++) {\n            const {\n              index,\n              frameIndex\n            } = calculatePixelIndices(row, col);\n            for (let channel = 0; channel < this._png.channels; channel++) {\n              const sourceAlpha = frame.data[frameIndex + this._png.channels - 1] / maxValue;\n              const foregroundValue = channel % (this._png.channels - 1) === 0 ? 1 : frame.data[frameIndex + channel];\n              const value = Math.floor(sourceAlpha * foregroundValue + (1 - sourceAlpha) * imageFrame.data[index + channel]);\n              imageFrame.data[index + channel] += value;\n            }\n          }\n        }\n        break;\n      default:\n        throw new Error('Unknown blendOp');\n    }\n  }\n  decodeImage() {\n    if (this._inflator.err) {\n      throw new Error(`Error while decompressing the data: ${this._inflator.err}`);\n    }\n    const data = this._isAnimated ? (this._frames?.at(0)).data : this._inflator.result;\n    if (this._filterMethod !== FilterMethod.ADAPTIVE) {\n      throw new Error(`Filter method ${this._filterMethod} not supported`);\n    }\n    if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {\n      this._png.data = decodeInterlaceNull({\n        data: data,\n        width: this._png.width,\n        height: this._png.height,\n        channels: this._png.channels,\n        depth: this._png.depth\n      });\n    } else if (this._interlaceMethod === InterlaceMethod.ADAM7) {\n      this._png.data = decodeInterlaceAdam7({\n        data: data,\n        width: this._png.width,\n        height: this._png.height,\n        channels: this._png.channels,\n        depth: this._png.depth\n      });\n    } else {\n      throw new Error(`Interlace method ${this._interlaceMethod} not supported`);\n    }\n    if (this._hasPalette) {\n      this._png.palette = this._palette;\n    }\n    if (this._hasTransparency) {\n      this._png.transparency = this._transparency;\n    }\n  }\n  pushDataToFrame() {\n    const result = this._inflator.result;\n    const lastFrame = this._frames.at(-1);\n    if (lastFrame) {\n      lastFrame.data = result;\n    } else {\n      this._frames.push({\n        sequenceNumber: 0,\n        width: this._png.width,\n        height: this._png.height,\n        xOffset: 0,\n        yOffset: 0,\n        delayNumber: 0,\n        delayDenominator: 0,\n        disposeOp: DisposeOpType.NONE,\n        blendOp: BlendOpType.SOURCE,\n        data: result\n      });\n    }\n    this._inflator = new Inflator();\n    this._writingDataChunks = false;\n  }\n}\nfunction checkBitDepth(value) {\n  if (value !== 1 && value !== 2 && value !== 4 && value !== 8 && value !== 16) {\n    throw new Error(`invalid bit depth: ${value}`);\n  }\n  return value;\n}","map":{"version":3,"names":["IOBuffer","inflate","Inflate","Inflator","checkCrc","decodeInterlaceAdam7","decodeInterlaceNull","checkSignature","decodetEXt","readKeyword","textChunkName","ColorType","CompressionMethod","DisposeOpType","FilterMethod","InterlaceMethod","BlendOpType","PngDecoder","_checkCrc","_inflator","_png","_apng","_end","_hasPalette","_palette","_hasTransparency","_transparency","_compressionMethod","_filterMethod","_interlaceMethod","_colorType","_isAnimated","_numberOfFrames","_numberOfPlays","_frames","_writingDataChunks","constructor","data","options","width","height","channels","Uint8Array","depth","text","numberOfFrames","numberOfPlays","frames","Uint16Array","UNKNOWN","setBigEndian","decode","length","readUint32","type","readChars","decodeChunk","decodeImage","decodeApng","decodeApngChunk","decodeApngImage","offset","decodeIHDR","decodePLTE","decodeIDAT","decodetRNS","decodeiCCP","decodepHYs","skip","Error","pushDataToFrame","decodeACTL","decodeFCTL","decodeFDAT","image","checkBitDepth","readUint8","colorType","GREYSCALE","TRUECOLOUR","INDEXED_COLOUR","GREYSCALE_ALPHA","TRUECOLOUR_ALPHA","DEFLATE","sequenceNumber","xOffset","yOffset","delayNumber","readUint16","delayDenominator","disposeOp","blendOp","push","RangeError","l","palette","i","dataLength","dataOffset","byteOffset","buffer","err","alpha","readByte","name","compressionMethod","compressedProfile","readBytes","iccEmbeddedProfile","profile","ppuX","ppuY","unitSpecifier","resolution","x","y","unit","newFrame","frame","at","transparency","prevFrame","disposeFrame","addFrameDataToCanvas","imageFrame","NONE","BACKGROUND","row","col","index","channel","PREVIOUS","set","maxValue","calculatePixelIndices","frameIndex","SOURCE","OVER","sourceAlpha","foregroundValue","value","Math","floor","result","ADAPTIVE","NO_INTERLACE","ADAM7","lastFrame"],"sources":["C:\\Users\\namil\\Desktop\\sanaapplenamlocal\\frontend\\node_modules\\fast-png\\src\\PngDecoder.ts"],"sourcesContent":["import { IOBuffer } from 'iobuffer';\r\nimport { inflate, Inflate as Inflator } from 'pako';\r\n\r\nimport { checkCrc } from './helpers/crc';\r\nimport { decodeInterlaceAdam7 } from './helpers/decodeInterlaceAdam7';\r\nimport { decodeInterlaceNull } from './helpers/decodeInterlaceNull';\r\nimport { checkSignature } from './helpers/signature';\r\nimport { decodetEXt, readKeyword, textChunkName } from './helpers/text';\r\nimport {\r\n  ColorType,\r\n  CompressionMethod,\r\n  DisposeOpType,\r\n  FilterMethod,\r\n  InterlaceMethod,\r\n  BlendOpType,\r\n} from './internalTypes';\r\nimport type {\r\n  BitDepth,\r\n  DecodedPng,\r\n  DecodedApng,\r\n  DecodedApngFrame,\r\n  ApngFrame,\r\n  DecoderInputType,\r\n  IndexedColors,\r\n  PngDecoderOptions,\r\n} from './types';\r\n\r\nexport default class PngDecoder extends IOBuffer {\r\n  private readonly _checkCrc: boolean;\r\n  private _inflator: Inflator;\r\n  private readonly _png: DecodedPng;\r\n  private readonly _apng: DecodedApng;\r\n  private _end: boolean;\r\n  private _hasPalette: boolean;\r\n  private _palette: IndexedColors;\r\n  private _hasTransparency: boolean;\r\n  private _transparency: Uint16Array;\r\n  private _compressionMethod: CompressionMethod;\r\n  private _filterMethod: FilterMethod;\r\n  private _interlaceMethod: InterlaceMethod;\r\n  private _colorType: ColorType;\r\n  private _isAnimated: boolean;\r\n  private _numberOfFrames: number;\r\n  private _numberOfPlays: number;\r\n  private _frames: ApngFrame[];\r\n  private _writingDataChunks: boolean;\r\n\r\n  public constructor(data: DecoderInputType, options: PngDecoderOptions = {}) {\r\n    super(data);\r\n    const { checkCrc = false } = options;\r\n    this._checkCrc = checkCrc;\r\n    this._inflator = new Inflator();\r\n    this._png = {\r\n      width: -1,\r\n      height: -1,\r\n      channels: -1,\r\n      data: new Uint8Array(0),\r\n      depth: 1,\r\n      text: {},\r\n    };\r\n    this._apng = {\r\n      width: -1,\r\n      height: -1,\r\n      channels: -1,\r\n      depth: 1,\r\n      numberOfFrames: 1,\r\n      numberOfPlays: 0,\r\n      text: {},\r\n      frames: [],\r\n    };\r\n    this._end = false;\r\n    this._hasPalette = false;\r\n    this._palette = [];\r\n    this._hasTransparency = false;\r\n    this._transparency = new Uint16Array(0);\r\n    this._compressionMethod = CompressionMethod.UNKNOWN;\r\n    this._filterMethod = FilterMethod.UNKNOWN;\r\n    this._interlaceMethod = InterlaceMethod.UNKNOWN;\r\n    this._colorType = ColorType.UNKNOWN;\r\n    this._isAnimated = false;\r\n    this._numberOfFrames = 1;\r\n    this._numberOfPlays = 0;\r\n    this._frames = [];\r\n    this._writingDataChunks = false;\r\n    // PNG is always big endian\r\n    // https://www.w3.org/TR/PNG/#7Integers-and-byte-order\r\n    this.setBigEndian();\r\n  }\r\n\r\n  public decode(): DecodedPng {\r\n    checkSignature(this);\r\n    while (!this._end) {\r\n      const length = this.readUint32();\r\n      const type = this.readChars(4);\r\n\r\n      this.decodeChunk(length, type);\r\n    }\r\n    this.decodeImage();\r\n\r\n    return this._png;\r\n  }\r\n\r\n  public decodeApng(): DecodedApng {\r\n    checkSignature(this);\r\n    while (!this._end) {\r\n      const length = this.readUint32();\r\n      const type = this.readChars(4);\r\n\r\n      this.decodeApngChunk(length, type);\r\n    }\r\n    this.decodeApngImage();\r\n    return this._apng;\r\n  }\r\n\r\n  // https://www.w3.org/TR/PNG/#5Chunk-layout\r\n  private decodeChunk(length: number, type: string): void {\r\n    const offset = this.offset;\r\n    switch (type) {\r\n      // 11.2 Critical chunks\r\n      case 'IHDR': // 11.2.2 IHDR Image header\r\n        this.decodeIHDR();\r\n        break;\r\n      case 'PLTE': // 11.2.3 PLTE Palette\r\n        this.decodePLTE(length);\r\n        break;\r\n      case 'IDAT': // 11.2.4 IDAT Image data\r\n        this.decodeIDAT(length);\r\n        break;\r\n      case 'IEND': // 11.2.5 IEND Image trailer\r\n        this._end = true;\r\n        break;\r\n      // 11.3 Ancillary chunks\r\n      case 'tRNS': // 11.3.2.1 tRNS Transparency\r\n        this.decodetRNS(length);\r\n        break;\r\n      case 'iCCP': // 11.3.3.3 iCCP Embedded ICC profile\r\n        this.decodeiCCP(length);\r\n        break;\r\n      case textChunkName: // 11.3.4.3 tEXt Textual data\r\n        decodetEXt(this._png.text, this, length);\r\n        break;\r\n      case 'pHYs': // 11.3.5.3 pHYs Physical pixel dimensions\r\n        this.decodepHYs();\r\n        break;\r\n      default:\r\n        this.skip(length);\r\n        break;\r\n    }\r\n    if (this.offset - offset !== length) {\r\n      throw new Error(`Length mismatch while decoding chunk ${type}`);\r\n    }\r\n    if (this._checkCrc) {\r\n      checkCrc(this, length + 4, type);\r\n    } else {\r\n      this.skip(4);\r\n    }\r\n  }\r\n  private decodeApngChunk(length: number, type: string): void {\r\n    const offset = this.offset;\r\n    if (type !== 'fdAT' && type !== 'IDAT' && this._writingDataChunks) {\r\n      this.pushDataToFrame();\r\n    }\r\n    switch (type) {\r\n      case 'acTL':\r\n        this.decodeACTL();\r\n        break;\r\n      case 'fcTL':\r\n        this.decodeFCTL();\r\n        break;\r\n      case 'fdAT':\r\n        this.decodeFDAT(length);\r\n        break;\r\n      default:\r\n        this.decodeChunk(length, type);\r\n        this.offset = offset + length;\r\n        break;\r\n    }\r\n    if (this.offset - offset !== length) {\r\n      throw new Error(`Length mismatch while decoding chunk ${type}`);\r\n    }\r\n    if (this._checkCrc) {\r\n      checkCrc(this, length + 4, type);\r\n    } else {\r\n      this.skip(4);\r\n    }\r\n  }\r\n\r\n  // https://www.w3.org/TR/PNG/#11IHDR\r\n  private decodeIHDR(): void {\r\n    const image = this._png;\r\n\r\n    image.width = this.readUint32();\r\n    image.height = this.readUint32();\r\n    image.depth = checkBitDepth(this.readUint8());\r\n\r\n    const colorType = this.readUint8() as ColorType;\r\n    this._colorType = colorType;\r\n    let channels: number;\r\n    switch (colorType) {\r\n      case ColorType.GREYSCALE:\r\n        channels = 1;\r\n        break;\r\n      case ColorType.TRUECOLOUR:\r\n        channels = 3;\r\n        break;\r\n      case ColorType.INDEXED_COLOUR:\r\n        channels = 1;\r\n        break;\r\n      case ColorType.GREYSCALE_ALPHA:\r\n        channels = 2;\r\n        break;\r\n      case ColorType.TRUECOLOUR_ALPHA:\r\n        channels = 4;\r\n        break;\r\n      // Kept for exhaustiveness.\r\n      // eslint-disable-next-line unicorn/no-useless-switch-case\r\n      case ColorType.UNKNOWN:\r\n      default:\r\n        throw new Error(`Unknown color type: ${colorType}`);\r\n    }\r\n    this._png.channels = channels;\r\n\r\n    this._compressionMethod = this.readUint8() as CompressionMethod;\r\n    if (this._compressionMethod !== CompressionMethod.DEFLATE) {\r\n      throw new Error(\r\n        `Unsupported compression method: ${this._compressionMethod}`,\r\n      );\r\n    }\r\n\r\n    this._filterMethod = this.readUint8() as FilterMethod;\r\n    this._interlaceMethod = this.readUint8() as InterlaceMethod;\r\n  }\r\n\r\n  private decodeACTL(): void {\r\n    this._numberOfFrames = this.readUint32();\r\n    this._numberOfPlays = this.readUint32();\r\n    this._isAnimated = true;\r\n  }\r\n\r\n  private decodeFCTL(): void {\r\n    const image: ApngFrame = {\r\n      sequenceNumber: this.readUint32(),\r\n      width: this.readUint32(),\r\n      height: this.readUint32(),\r\n      xOffset: this.readUint32(),\r\n      yOffset: this.readUint32(),\r\n      delayNumber: this.readUint16(),\r\n      delayDenominator: this.readUint16(),\r\n      disposeOp: this.readUint8(),\r\n      blendOp: this.readUint8(),\r\n      data: new Uint8Array(0),\r\n    };\r\n    this._frames.push(image);\r\n  }\r\n  // https://www.w3.org/TR/PNG/#11PLTE\r\n  private decodePLTE(length: number): void {\r\n    if (length % 3 !== 0) {\r\n      throw new RangeError(\r\n        `PLTE field length must be a multiple of 3. Got ${length}`,\r\n      );\r\n    }\r\n    const l = length / 3;\r\n\r\n    this._hasPalette = true;\r\n    const palette: IndexedColors = [];\r\n    this._palette = palette;\r\n    for (let i = 0; i < l; i++) {\r\n      palette.push([this.readUint8(), this.readUint8(), this.readUint8()]);\r\n    }\r\n  }\r\n\r\n  // https://www.w3.org/TR/PNG/#11IDAT\r\n  private decodeIDAT(length: number): void {\r\n    this._writingDataChunks = true;\r\n    const dataLength = length;\r\n    const dataOffset = this.offset + this.byteOffset;\r\n\r\n    this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));\r\n    if (this._inflator.err) {\r\n      throw new Error(\r\n        `Error while decompressing the data: ${this._inflator.err}`,\r\n      );\r\n    }\r\n    this.skip(length);\r\n  }\r\n  private decodeFDAT(length: number): void {\r\n    this._writingDataChunks = true;\r\n    let dataLength = length;\r\n    let dataOffset = this.offset + this.byteOffset;\r\n    dataOffset += 4;\r\n    dataLength -= 4;\r\n    this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));\r\n    if (this._inflator.err) {\r\n      throw new Error(\r\n        `Error while decompressing the data: ${this._inflator.err}`,\r\n      );\r\n    }\r\n    this.skip(length);\r\n  }\r\n\r\n  // https://www.w3.org/TR/PNG/#11tRNS\r\n  private decodetRNS(length: number): void {\r\n    switch (this._colorType) {\r\n      case ColorType.GREYSCALE:\r\n      case ColorType.TRUECOLOUR: {\r\n        if (length % 2 !== 0) {\r\n          throw new RangeError(\r\n            `tRNS chunk length must be a multiple of 2. Got ${length}`,\r\n          );\r\n        }\r\n        if (length / 2 > this._png.width * this._png.height) {\r\n          throw new Error(\r\n            `tRNS chunk contains more alpha values than there are pixels (${\r\n              length / 2\r\n            } vs ${this._png.width * this._png.height})`,\r\n          );\r\n        }\r\n        this._hasTransparency = true;\r\n        this._transparency = new Uint16Array(length / 2);\r\n\r\n        for (let i = 0; i < length / 2; i++) {\r\n          this._transparency[i] = this.readUint16();\r\n        }\r\n\r\n        break;\r\n      }\r\n      case ColorType.INDEXED_COLOUR: {\r\n        if (length > this._palette.length) {\r\n          throw new Error(\r\n            `tRNS chunk contains more alpha values than there are palette colors (${length} vs ${this._palette.length})`,\r\n          );\r\n        }\r\n        let i = 0;\r\n        for (; i < length; i++) {\r\n          const alpha = this.readByte();\r\n          this._palette[i].push(alpha);\r\n        }\r\n        for (; i < this._palette.length; i++) {\r\n          this._palette[i].push(255);\r\n        }\r\n        break;\r\n      }\r\n      // Kept for exhaustiveness.\r\n      /* eslint-disable unicorn/no-useless-switch-case */\r\n      case ColorType.UNKNOWN:\r\n      case ColorType.GREYSCALE_ALPHA:\r\n      case ColorType.TRUECOLOUR_ALPHA:\r\n      default: {\r\n        throw new Error(\r\n          `tRNS chunk is not supported for color type ${this._colorType}`,\r\n        );\r\n      }\r\n      /* eslint-enable unicorn/no-useless-switch-case */\r\n    }\r\n  }\r\n\r\n  // https://www.w3.org/TR/PNG/#11iCCP\r\n  private decodeiCCP(length: number): void {\r\n    const name = readKeyword(this);\r\n    const compressionMethod = this.readUint8();\r\n    if (compressionMethod !== CompressionMethod.DEFLATE) {\r\n      throw new Error(\r\n        `Unsupported iCCP compression method: ${compressionMethod}`,\r\n      );\r\n    }\r\n    const compressedProfile = this.readBytes(length - name.length - 2);\r\n    this._png.iccEmbeddedProfile = {\r\n      name,\r\n      profile: inflate(compressedProfile),\r\n    };\r\n  }\r\n\r\n  // https://www.w3.org/TR/PNG/#11pHYs\r\n  private decodepHYs(): void {\r\n    const ppuX = this.readUint32();\r\n    const ppuY = this.readUint32();\r\n    const unitSpecifier = this.readByte();\r\n    this._png.resolution = { x: ppuX, y: ppuY, unit: unitSpecifier };\r\n  }\r\n\r\n  private decodeApngImage() {\r\n    this._apng.width = this._png.width;\r\n    this._apng.height = this._png.height;\r\n    this._apng.channels = this._png.channels;\r\n    this._apng.depth = this._png.depth;\r\n    this._apng.numberOfFrames = this._numberOfFrames;\r\n    this._apng.numberOfPlays = this._numberOfPlays;\r\n    this._apng.text = this._png.text;\r\n    this._apng.resolution = this._png.resolution;\r\n    for (let i = 0; i < this._numberOfFrames; i++) {\r\n      const newFrame: DecodedApngFrame = {\r\n        sequenceNumber: this._frames[i].sequenceNumber,\r\n        delayNumber: this._frames[i].delayNumber,\r\n        delayDenominator: this._frames[i].delayDenominator,\r\n        data:\r\n          this._apng.depth === 8\r\n            ? new Uint8Array(\r\n                this._apng.width * this._apng.height * this._apng.channels,\r\n              )\r\n            : new Uint16Array(\r\n                this._apng.width * this._apng.height * this._apng.channels,\r\n              ),\r\n      };\r\n\r\n      const frame = this._frames.at(i);\r\n\r\n      if (frame) {\r\n        frame.data = decodeInterlaceNull({\r\n          data: frame.data as Uint8Array,\r\n          width: frame.width,\r\n          height: frame.height,\r\n          channels: this._apng.channels,\r\n          depth: this._apng.depth,\r\n        });\r\n\r\n        if (this._hasPalette) {\r\n          this._apng.palette = this._palette;\r\n        }\r\n        if (this._hasTransparency) {\r\n          this._apng.transparency = this._transparency;\r\n        }\r\n        if (\r\n          i === 0 ||\r\n          (frame.xOffset === 0 &&\r\n            frame.yOffset === 0 &&\r\n            frame.width === this._png.width &&\r\n            frame.height === this._png.height)\r\n        ) {\r\n          newFrame.data = frame.data;\r\n        } else {\r\n          const prevFrame = this._apng.frames.at(i - 1);\r\n          this.disposeFrame(frame, prevFrame as DecodedApngFrame, newFrame);\r\n          this.addFrameDataToCanvas(newFrame, frame);\r\n        }\r\n        this._apng.frames.push(newFrame);\r\n      }\r\n    }\r\n    return this._apng;\r\n  }\r\n  private disposeFrame(\r\n    frame: ApngFrame,\r\n    prevFrame: DecodedApngFrame,\r\n    imageFrame: DecodedApngFrame,\r\n  ): void {\r\n    switch (frame.disposeOp) {\r\n      case DisposeOpType.NONE:\r\n        break;\r\n      case DisposeOpType.BACKGROUND:\r\n        for (let row = 0; row < this._png.height; row++) {\r\n          for (let col = 0; col < this._png.width; col++) {\r\n            const index = (row * frame.width + col) * this._png.channels;\r\n            for (let channel = 0; channel < this._png.channels; channel++) {\r\n              imageFrame.data[index + channel] = 0;\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      case DisposeOpType.PREVIOUS:\r\n        imageFrame.data.set(prevFrame.data);\r\n        break;\r\n      default:\r\n        throw new Error('Unknown disposeOp');\r\n    }\r\n  }\r\n  private addFrameDataToCanvas(\r\n    imageFrame: DecodedApngFrame,\r\n    frame: ApngFrame,\r\n  ): void {\r\n    const maxValue = 1 << this._png.depth;\r\n    const calculatePixelIndices = (row: number, col: number) => {\r\n      const index =\r\n        ((row + frame.yOffset) * this._png.width + frame.xOffset + col) *\r\n        this._png.channels;\r\n      const frameIndex = (row * frame.width + col) * this._png.channels;\r\n      return { index, frameIndex };\r\n    };\r\n    switch (frame.blendOp) {\r\n      case BlendOpType.SOURCE:\r\n        for (let row = 0; row < frame.height; row++) {\r\n          for (let col = 0; col < frame.width; col++) {\r\n            const { index, frameIndex } = calculatePixelIndices(row, col);\r\n            for (let channel = 0; channel < this._png.channels; channel++) {\r\n              imageFrame.data[index + channel] =\r\n                frame.data[frameIndex + channel];\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      // https://www.w3.org/TR/png-3/#13Alpha-channel-processing\r\n      case BlendOpType.OVER:\r\n        for (let row = 0; row < frame.height; row++) {\r\n          for (let col = 0; col < frame.width; col++) {\r\n            const { index, frameIndex } = calculatePixelIndices(row, col);\r\n            for (let channel = 0; channel < this._png.channels; channel++) {\r\n              const sourceAlpha =\r\n                frame.data[frameIndex + this._png.channels - 1] / maxValue;\r\n              const foregroundValue =\r\n                channel % (this._png.channels - 1) === 0\r\n                  ? 1\r\n                  : frame.data[frameIndex + channel];\r\n              const value = Math.floor(\r\n                sourceAlpha * foregroundValue +\r\n                  (1 - sourceAlpha) * imageFrame.data[index + channel],\r\n              );\r\n              imageFrame.data[index + channel] += value;\r\n            }\r\n          }\r\n        }\r\n        break;\r\n      default:\r\n        throw new Error('Unknown blendOp');\r\n    }\r\n  }\r\n  private decodeImage(): void {\r\n    if (this._inflator.err) {\r\n      throw new Error(\r\n        `Error while decompressing the data: ${this._inflator.err}`,\r\n      );\r\n    }\r\n\r\n    const data = this._isAnimated\r\n      ? (this._frames?.at(0) as ApngFrame).data\r\n      : this._inflator.result;\r\n\r\n    if (this._filterMethod !== FilterMethod.ADAPTIVE) {\r\n      throw new Error(`Filter method ${this._filterMethod} not supported`);\r\n    }\r\n\r\n    if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {\r\n      this._png.data = decodeInterlaceNull({\r\n        data: data as Uint8Array,\r\n        width: this._png.width,\r\n        height: this._png.height,\r\n        channels: this._png.channels,\r\n        depth: this._png.depth,\r\n      });\r\n    } else if (this._interlaceMethod === InterlaceMethod.ADAM7) {\r\n      this._png.data = decodeInterlaceAdam7({\r\n        data: data as Uint8Array,\r\n        width: this._png.width,\r\n        height: this._png.height,\r\n        channels: this._png.channels,\r\n        depth: this._png.depth,\r\n      });\r\n    } else {\r\n      throw new Error(\r\n        `Interlace method ${this._interlaceMethod} not supported`,\r\n      );\r\n    }\r\n\r\n    if (this._hasPalette) {\r\n      this._png.palette = this._palette;\r\n    }\r\n    if (this._hasTransparency) {\r\n      this._png.transparency = this._transparency;\r\n    }\r\n  }\r\n\r\n  private pushDataToFrame() {\r\n    const result = this._inflator.result;\r\n    const lastFrame = this._frames.at(-1);\r\n    if (lastFrame) {\r\n      lastFrame.data = result as Uint8Array;\r\n    } else {\r\n      this._frames.push({\r\n        sequenceNumber: 0,\r\n        width: this._png.width,\r\n        height: this._png.height,\r\n        xOffset: 0,\r\n        yOffset: 0,\r\n        delayNumber: 0,\r\n        delayDenominator: 0,\r\n        disposeOp: DisposeOpType.NONE,\r\n        blendOp: BlendOpType.SOURCE,\r\n        data: result as Uint8Array,\r\n      });\r\n    }\r\n    this._inflator = new Inflator();\r\n    this._writingDataChunks = false;\r\n  }\r\n}\r\n\r\nfunction checkBitDepth(value: number): BitDepth {\r\n  if (\r\n    value !== 1 &&\r\n    value !== 2 &&\r\n    value !== 4 &&\r\n    value !== 8 &&\r\n    value !== 16\r\n  ) {\r\n    throw new Error(`invalid bit depth: ${value}`);\r\n  }\r\n  return value;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}