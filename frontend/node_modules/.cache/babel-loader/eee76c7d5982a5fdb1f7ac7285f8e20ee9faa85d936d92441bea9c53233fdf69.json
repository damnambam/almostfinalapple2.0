{"ast":null,"code":"const crcTable = [];\nfor (let n = 0; n < 256; n++) {\n  let c = n;\n  for (let k = 0; k < 8; k++) {\n    if (c & 1) {\n      c = 0xedb88320 ^ c >>> 1;\n    } else {\n      c = c >>> 1;\n    }\n  }\n  crcTable[n] = c;\n}\nconst initialCrc = 0xffffffff;\nfunction updateCrc(currentCrc, data, length) {\n  let c = currentCrc;\n  for (let n = 0; n < length; n++) {\n    c = crcTable[(c ^ data[n]) & 0xff] ^ c >>> 8;\n  }\n  return c;\n}\nfunction crc(data, length) {\n  return (updateCrc(initialCrc, data, length) ^ initialCrc) >>> 0;\n}\nexport function checkCrc(buffer, crcLength, chunkName) {\n  const expectedCrc = buffer.readUint32();\n  const actualCrc = crc(new Uint8Array(buffer.buffer, buffer.byteOffset + buffer.offset - crcLength - 4, crcLength), crcLength); // \"- 4\" because we already advanced by reading the CRC\n  if (actualCrc !== expectedCrc) {\n    throw new Error(`CRC mismatch for chunk ${chunkName}. Expected ${expectedCrc}, found ${actualCrc}`);\n  }\n}\nexport function writeCrc(buffer, length) {\n  buffer.writeUint32(crc(new Uint8Array(buffer.buffer, buffer.byteOffset + buffer.offset - length, length), length));\n}","map":{"version":3,"names":["crcTable","n","c","k","initialCrc","updateCrc","currentCrc","data","length","crc","checkCrc","buffer","crcLength","chunkName","expectedCrc","readUint32","actualCrc","Uint8Array","byteOffset","offset","Error","writeCrc","writeUint32"],"sources":["C:\\Users\\namil\\Desktop\\sanaapplenamlocal\\frontend\\node_modules\\fast-png\\src\\helpers\\crc.ts"],"sourcesContent":["import type { IOBuffer } from 'iobuffer';\r\n\r\nconst crcTable: number[] = [];\r\nfor (let n = 0; n < 256; n++) {\r\n  let c = n;\r\n  for (let k = 0; k < 8; k++) {\r\n    if (c & 1) {\r\n      c = 0xedb88320 ^ (c >>> 1);\r\n    } else {\r\n      c = c >>> 1;\r\n    }\r\n  }\r\n  crcTable[n] = c;\r\n}\r\n\r\nconst initialCrc = 0xffffffff;\r\nfunction updateCrc(\r\n  currentCrc: number,\r\n  data: Uint8Array,\r\n  length: number,\r\n): number {\r\n  let c = currentCrc;\r\n  for (let n = 0; n < length; n++) {\r\n    c = crcTable[(c ^ data[n]) & 0xff] ^ (c >>> 8);\r\n  }\r\n  return c;\r\n}\r\n\r\nfunction crc(data: Uint8Array, length: number): number {\r\n  return (updateCrc(initialCrc, data, length) ^ initialCrc) >>> 0;\r\n}\r\n\r\nexport function checkCrc(\r\n  buffer: IOBuffer,\r\n  crcLength: number,\r\n  chunkName: string,\r\n) {\r\n  const expectedCrc = buffer.readUint32();\r\n  const actualCrc = crc(\r\n    new Uint8Array(\r\n      buffer.buffer,\r\n      buffer.byteOffset + buffer.offset - crcLength - 4,\r\n      crcLength,\r\n    ),\r\n    crcLength,\r\n  ); // \"- 4\" because we already advanced by reading the CRC\r\n  if (actualCrc !== expectedCrc) {\r\n    throw new Error(\r\n      `CRC mismatch for chunk ${chunkName}. Expected ${expectedCrc}, found ${actualCrc}`,\r\n    );\r\n  }\r\n}\r\n\r\nexport function writeCrc(buffer: IOBuffer, length: number) {\r\n  buffer.writeUint32(\r\n    crc(\r\n      new Uint8Array(\r\n        buffer.buffer,\r\n        buffer.byteOffset + buffer.offset - length,\r\n        length,\r\n      ),\r\n      length,\r\n    ),\r\n  );\r\n}\r\n"],"mappings":"AAEA,MAAMA,QAAQ,GAAa,EAAE;AAC7B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,GAAG,EAAEA,CAAC,EAAE,EAAE;EAC5B,IAAIC,CAAC,GAAGD,CAAC;EACT,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC1B,IAAID,CAAC,GAAG,CAAC,EAAE;MACTA,CAAC,GAAG,UAAU,GAAIA,CAAC,KAAK,CAAE;IAC5B,CAAC,MAAM;MACLA,CAAC,GAAGA,CAAC,KAAK,CAAC;IACb;EACF;EACAF,QAAQ,CAACC,CAAC,CAAC,GAAGC,CAAC;AACjB;AAEA,MAAME,UAAU,GAAG,UAAU;AAC7B,SAASC,SAASA,CAChBC,UAAkB,EAClBC,IAAgB,EAChBC,MAAc;EAEd,IAAIN,CAAC,GAAGI,UAAU;EAClB,KAAK,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGO,MAAM,EAAEP,CAAC,EAAE,EAAE;IAC/BC,CAAC,GAAGF,QAAQ,CAAC,CAACE,CAAC,GAAGK,IAAI,CAACN,CAAC,CAAC,IAAI,IAAI,CAAC,GAAIC,CAAC,KAAK,CAAE;EAChD;EACA,OAAOA,CAAC;AACV;AAEA,SAASO,GAAGA,CAACF,IAAgB,EAAEC,MAAc;EAC3C,OAAO,CAACH,SAAS,CAACD,UAAU,EAAEG,IAAI,EAAEC,MAAM,CAAC,GAAGJ,UAAU,MAAM,CAAC;AACjE;AAEA,OAAM,SAAUM,QAAQA,CACtBC,MAAgB,EAChBC,SAAiB,EACjBC,SAAiB;EAEjB,MAAMC,WAAW,GAAGH,MAAM,CAACI,UAAU,EAAE;EACvC,MAAMC,SAAS,GAAGP,GAAG,CACnB,IAAIQ,UAAU,CACZN,MAAM,CAACA,MAAM,EACbA,MAAM,CAACO,UAAU,GAAGP,MAAM,CAACQ,MAAM,GAAGP,SAAS,GAAG,CAAC,EACjDA,SAAS,CACV,EACDA,SAAS,CACV,CAAC,CAAC;EACH,IAAII,SAAS,KAAKF,WAAW,EAAE;IAC7B,MAAM,IAAIM,KAAK,CACb,0BAA0BP,SAAS,cAAcC,WAAW,WAAWE,SAAS,EAAE,CACnF;EACH;AACF;AAEA,OAAM,SAAUK,QAAQA,CAACV,MAAgB,EAAEH,MAAc;EACvDG,MAAM,CAACW,WAAW,CAChBb,GAAG,CACD,IAAIQ,UAAU,CACZN,MAAM,CAACA,MAAM,EACbA,MAAM,CAACO,UAAU,GAAGP,MAAM,CAACQ,MAAM,GAAGX,MAAM,EAC1CA,MAAM,CACP,EACDA,MAAM,CACP,CACF;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}