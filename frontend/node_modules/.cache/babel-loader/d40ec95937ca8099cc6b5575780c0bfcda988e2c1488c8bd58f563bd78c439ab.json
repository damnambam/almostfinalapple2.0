{"ast":null,"code":"/**\r\n * Converts indexed data into RGB/RGBA format\r\n * @param decodedImage - Image to decode data from.\r\n * @returns Uint8Array with RGB data.\r\n */\nexport function convertIndexedToRgb(decodedImage) {\n  const palette = decodedImage.palette;\n  const depth = decodedImage.depth;\n  if (!palette) {\n    throw new Error('Color palette is undefined.');\n  }\n  checkDataSize(decodedImage);\n  const indexSize = decodedImage.width * decodedImage.height;\n  const resSize = indexSize * palette[0].length;\n  const res = new Uint8Array(resSize);\n  let indexPos = 0;\n  let offset = 0;\n  const indexes = new Uint8Array(indexSize);\n  let bit = 0xff;\n  switch (depth) {\n    case 1:\n      bit = 0x80;\n      break;\n    case 2:\n      bit = 0xc0;\n      break;\n    case 4:\n      bit = 0xf0;\n      break;\n    case 8:\n      bit = 0xff;\n      break;\n    default:\n      throw new Error('Incorrect depth value');\n  }\n  for (const byte of decodedImage.data) {\n    let bit2 = bit;\n    let shift = 8;\n    while (bit2) {\n      shift -= depth;\n      indexes[indexPos++] = (byte & bit2) >> shift;\n      bit2 = bit2 >> depth;\n      if (indexPos % decodedImage.width === 0) {\n        break;\n      }\n    }\n  }\n  if (decodedImage.palette) {\n    for (const index of indexes) {\n      const color = decodedImage.palette.at(index);\n      if (!color) {\n        throw new Error('Incorrect index of palette color');\n      }\n      res.set(color, offset);\n      offset += color.length;\n    }\n  }\n  return res;\n}\nfunction checkDataSize(image) {\n  const expectedSize = image.depth < 8 ? Math.ceil(image.width * image.depth / 8) * image.height * image.channels : image.width * image.height * image.channels;\n  if (image.data.length !== expectedSize) {\n    throw new RangeError(`wrong data size. Found ${image.data.length}, expected ${expectedSize}`);\n  }\n}","map":{"version":3,"names":["convertIndexedToRgb","decodedImage","palette","depth","Error","checkDataSize","indexSize","width","height","resSize","length","res","Uint8Array","indexPos","offset","indexes","bit","byte","data","bit2","shift","index","color","at","set","image","expectedSize","Math","ceil","channels","RangeError"],"sources":["C:\\Users\\namil\\Desktop\\sanaapplenamlocal\\frontend\\node_modules\\fast-png\\src\\convertIndexedToRgb.ts"],"sourcesContent":["import type { DecodedPng, IndexedColorBitDepth } from './types';\r\n\r\n/**\r\n * Converts indexed data into RGB/RGBA format\r\n * @param decodedImage - Image to decode data from.\r\n * @returns Uint8Array with RGB data.\r\n */\r\nexport function convertIndexedToRgb(decodedImage: DecodedPng) {\r\n  const palette = decodedImage.palette;\r\n  const depth = decodedImage.depth as IndexedColorBitDepth;\r\n  if (!palette) {\r\n    throw new Error('Color palette is undefined.');\r\n  }\r\n  checkDataSize(decodedImage);\r\n  const indexSize = decodedImage.width * decodedImage.height;\r\n  const resSize = indexSize * palette[0].length;\r\n  const res = new Uint8Array(resSize);\r\n  let indexPos = 0;\r\n  let offset = 0;\r\n  const indexes = new Uint8Array(indexSize);\r\n  let bit = 0xff;\r\n  switch (depth) {\r\n    case 1:\r\n      bit = 0x80;\r\n      break;\r\n    case 2:\r\n      bit = 0xc0;\r\n      break;\r\n    case 4:\r\n      bit = 0xf0;\r\n      break;\r\n    case 8:\r\n      bit = 0xff;\r\n      break;\r\n    default:\r\n      throw new Error('Incorrect depth value');\r\n  }\r\n  for (const byte of decodedImage.data) {\r\n    let bit2 = bit;\r\n    let shift = 8;\r\n    while (bit2) {\r\n      shift -= depth;\r\n      indexes[indexPos++] = (byte & bit2) >> shift;\r\n\r\n      bit2 = bit2 >> depth;\r\n      if (indexPos % decodedImage.width === 0) {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  if (decodedImage.palette) {\r\n    for (const index of indexes) {\r\n      const color = decodedImage.palette.at(index);\r\n      if (!color) {\r\n        throw new Error('Incorrect index of palette color');\r\n      }\r\n      res.set(color, offset);\r\n      offset += color.length;\r\n    }\r\n  }\r\n  return res;\r\n}\r\n\r\nfunction checkDataSize(image: DecodedPng): void {\r\n  const expectedSize =\r\n    image.depth < 8\r\n      ? Math.ceil((image.width * image.depth) / 8) *\r\n        image.height *\r\n        image.channels\r\n      : image.width * image.height * image.channels;\r\n\r\n  if (image.data.length !== expectedSize) {\r\n    throw new RangeError(\r\n      `wrong data size. Found ${image.data.length}, expected ${expectedSize}`,\r\n    );\r\n  }\r\n}\r\n"],"mappings":"AAEA;;;;;AAKA,OAAM,SAAUA,mBAAmBA,CAACC,YAAwB;EAC1D,MAAMC,OAAO,GAAGD,YAAY,CAACC,OAAO;EACpC,MAAMC,KAAK,GAAGF,YAAY,CAACE,KAA6B;EACxD,IAAI,CAACD,OAAO,EAAE;IACZ,MAAM,IAAIE,KAAK,CAAC,6BAA6B,CAAC;EAChD;EACAC,aAAa,CAACJ,YAAY,CAAC;EAC3B,MAAMK,SAAS,GAAGL,YAAY,CAACM,KAAK,GAAGN,YAAY,CAACO,MAAM;EAC1D,MAAMC,OAAO,GAAGH,SAAS,GAAGJ,OAAO,CAAC,CAAC,CAAC,CAACQ,MAAM;EAC7C,MAAMC,GAAG,GAAG,IAAIC,UAAU,CAACH,OAAO,CAAC;EACnC,IAAII,QAAQ,GAAG,CAAC;EAChB,IAAIC,MAAM,GAAG,CAAC;EACd,MAAMC,OAAO,GAAG,IAAIH,UAAU,CAACN,SAAS,CAAC;EACzC,IAAIU,GAAG,GAAG,IAAI;EACd,QAAQb,KAAK;IACX,KAAK,CAAC;MACJa,GAAG,GAAG,IAAI;MACV;IACF,KAAK,CAAC;MACJA,GAAG,GAAG,IAAI;MACV;IACF,KAAK,CAAC;MACJA,GAAG,GAAG,IAAI;MACV;IACF,KAAK,CAAC;MACJA,GAAG,GAAG,IAAI;MACV;IACF;MACE,MAAM,IAAIZ,KAAK,CAAC,uBAAuB,CAAC;EAC5C;EACA,KAAK,MAAMa,IAAI,IAAIhB,YAAY,CAACiB,IAAI,EAAE;IACpC,IAAIC,IAAI,GAAGH,GAAG;IACd,IAAII,KAAK,GAAG,CAAC;IACb,OAAOD,IAAI,EAAE;MACXC,KAAK,IAAIjB,KAAK;MACdY,OAAO,CAACF,QAAQ,EAAE,CAAC,GAAG,CAACI,IAAI,GAAGE,IAAI,KAAKC,KAAK;MAE5CD,IAAI,GAAGA,IAAI,IAAIhB,KAAK;MACpB,IAAIU,QAAQ,GAAGZ,YAAY,CAACM,KAAK,KAAK,CAAC,EAAE;QACvC;MACF;IACF;EACF;EAEA,IAAIN,YAAY,CAACC,OAAO,EAAE;IACxB,KAAK,MAAMmB,KAAK,IAAIN,OAAO,EAAE;MAC3B,MAAMO,KAAK,GAAGrB,YAAY,CAACC,OAAO,CAACqB,EAAE,CAACF,KAAK,CAAC;MAC5C,IAAI,CAACC,KAAK,EAAE;QACV,MAAM,IAAIlB,KAAK,CAAC,kCAAkC,CAAC;MACrD;MACAO,GAAG,CAACa,GAAG,CAACF,KAAK,EAAER,MAAM,CAAC;MACtBA,MAAM,IAAIQ,KAAK,CAACZ,MAAM;IACxB;EACF;EACA,OAAOC,GAAG;AACZ;AAEA,SAASN,aAAaA,CAACoB,KAAiB;EACtC,MAAMC,YAAY,GAChBD,KAAK,CAACtB,KAAK,GAAG,CAAC,GACXwB,IAAI,CAACC,IAAI,CAAEH,KAAK,CAAClB,KAAK,GAAGkB,KAAK,CAACtB,KAAK,GAAI,CAAC,CAAC,GAC1CsB,KAAK,CAACjB,MAAM,GACZiB,KAAK,CAACI,QAAQ,GACdJ,KAAK,CAAClB,KAAK,GAAGkB,KAAK,CAACjB,MAAM,GAAGiB,KAAK,CAACI,QAAQ;EAEjD,IAAIJ,KAAK,CAACP,IAAI,CAACR,MAAM,KAAKgB,YAAY,EAAE;IACtC,MAAM,IAAII,UAAU,CAClB,0BAA0BL,KAAK,CAACP,IAAI,CAACR,MAAM,cAAcgB,YAAY,EAAE,CACxE;EACH;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}